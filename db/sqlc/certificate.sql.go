// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: certificate.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const getCertificate = `-- name: GetCertificate :one
SELECT serial_number, account, environment, extended_key, common_name, subject_alternative_name, expiration_date, issued_date, revoked, revoked_by, revoke_date, certificate_authority_arn FROM certificates
WHERE serial_number = $1
`

func (q *Queries) GetCertificate(ctx context.Context, serialNumber string) (*Certificate, error) {
	row := q.db.QueryRowContext(ctx, getCertificate, serialNumber)
	var i Certificate
	err := row.Scan(
		&i.SerialNumber,
		&i.Account,
		&i.Environment,
		&i.ExtendedKey,
		&i.CommonName,
		pq.Array(&i.SubjectAlternativeName),
		&i.ExpirationDate,
		&i.IssuedDate,
		&i.Revoked,
		&i.RevokedBy,
		&i.RevokeDate,
		&i.CertificateAuthorityArn,
	)
	return &i, err
}

const getSignedCertificateByMetadata = `-- name: GetSignedCertificateByMetadata :many
SELECT serial_number, account, environment, extended_key, common_name, subject_alternative_name, expiration_date, issued_date, revoked, revoked_by, revoke_date, certificate_authority_arn FROM certificates
WHERE serial_number LIKE $1 AND account LIKE $2 AND environment LIKE $3 AND extended_key LIKE $4
`

type GetSignedCertificateByMetadataParams struct {
	SerialNumber string `json:"serial_number"`
	Account      string `json:"account"`
	Environment  string `json:"environment"`
	ExtendedKey  string `json:"extended_key"`
}

func (q *Queries) GetSignedCertificateByMetadata(ctx context.Context, arg GetSignedCertificateByMetadataParams) ([]*Certificate, error) {
	rows, err := q.db.QueryContext(ctx, getSignedCertificateByMetadata,
		arg.SerialNumber,
		arg.Account,
		arg.Environment,
		arg.ExtendedKey,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Certificate{}
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.SerialNumber,
			&i.Account,
			&i.Environment,
			&i.ExtendedKey,
			&i.CommonName,
			pq.Array(&i.SubjectAlternativeName),
			&i.ExpirationDate,
			&i.IssuedDate,
			&i.Revoked,
			&i.RevokedBy,
			&i.RevokeDate,
			&i.CertificateAuthorityArn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificateSubjectAlternativeName = `-- name: ListCertificateSubjectAlternativeName :many
SELECT serial_number, account, environment, extended_key, common_name, subject_alternative_name, expiration_date, issued_date, revoked, revoked_by, revoke_date, certificate_authority_arn FROM certificates
WHERE common_name = $1 OR $1 = ANY(subject_alternative_name)
LIMIT $2
OFFSET $3
`

type ListCertificateSubjectAlternativeNameParams struct {
	CommonName string `json:"common_name"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListCertificateSubjectAlternativeName(ctx context.Context, arg ListCertificateSubjectAlternativeNameParams) ([]*Certificate, error) {
	rows, err := q.db.QueryContext(ctx, listCertificateSubjectAlternativeName, arg.CommonName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Certificate{}
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.SerialNumber,
			&i.Account,
			&i.Environment,
			&i.ExtendedKey,
			&i.CommonName,
			pq.Array(&i.SubjectAlternativeName),
			&i.ExpirationDate,
			&i.IssuedDate,
			&i.Revoked,
			&i.RevokedBy,
			&i.RevokeDate,
			&i.CertificateAuthorityArn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificates = `-- name: ListCertificates :many
SELECT serial_number, account, environment, extended_key, common_name, subject_alternative_name, expiration_date, issued_date, revoked, revoked_by, revoke_date, certificate_authority_arn FROM certificates
LIMIT $1
OFFSET $2
`

type ListCertificatesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCertificates(ctx context.Context, arg ListCertificatesParams) ([]*Certificate, error) {
	rows, err := q.db.QueryContext(ctx, listCertificates, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Certificate{}
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.SerialNumber,
			&i.Account,
			&i.Environment,
			&i.ExtendedKey,
			&i.CommonName,
			pq.Array(&i.SubjectAlternativeName),
			&i.ExpirationDate,
			&i.IssuedDate,
			&i.Revoked,
			&i.RevokedBy,
			&i.RevokeDate,
			&i.CertificateAuthorityArn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logCertificate = `-- name: LogCertificate :one
INSERT INTO certificates (
    serial_number,
    account,
    environment,
    extended_key,
    common_name,
    subject_alternative_name,
    expiration_date,
    issued_date,
    certificate_authority_arn
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING serial_number, account, environment, extended_key, common_name, subject_alternative_name, expiration_date, issued_date, revoked, revoked_by, revoke_date, certificate_authority_arn
`

type LogCertificateParams struct {
	SerialNumber            string         `json:"serial_number"`
	Account                 string         `json:"account"`
	Environment             string         `json:"environment"`
	ExtendedKey             string         `json:"extended_key"`
	CommonName              string         `json:"common_name"`
	SubjectAlternativeName  []string       `json:"subject_alternative_name"`
	ExpirationDate          time.Time      `json:"expiration_date"`
	IssuedDate              time.Time      `json:"issued_date"`
	CertificateAuthorityArn sql.NullString `json:"certificate_authority_arn"`
}

func (q *Queries) LogCertificate(ctx context.Context, arg LogCertificateParams) (*Certificate, error) {
	row := q.db.QueryRowContext(ctx, logCertificate,
		arg.SerialNumber,
		arg.Account,
		arg.Environment,
		arg.ExtendedKey,
		arg.CommonName,
		pq.Array(arg.SubjectAlternativeName),
		arg.ExpirationDate,
		arg.IssuedDate,
		arg.CertificateAuthorityArn,
	)
	var i Certificate
	err := row.Scan(
		&i.SerialNumber,
		&i.Account,
		&i.Environment,
		&i.ExtendedKey,
		&i.CommonName,
		pq.Array(&i.SubjectAlternativeName),
		&i.ExpirationDate,
		&i.IssuedDate,
		&i.Revoked,
		&i.RevokedBy,
		&i.RevokeDate,
		&i.CertificateAuthorityArn,
	)
	return &i, err
}

const revokeIssuedCertificateSerialNumber = `-- name: RevokeIssuedCertificateSerialNumber :exec
UPDATE certificates
SET revoked = TRUE, revoke_date = $2, revoked_by = $3
WHERE serial_number = $1
`

type RevokeIssuedCertificateSerialNumberParams struct {
	SerialNumber string         `json:"serial_number"`
	RevokeDate   sql.NullTime   `json:"revoke_date"`
	RevokedBy    sql.NullString `json:"revoked_by"`
}

func (q *Queries) RevokeIssuedCertificateSerialNumber(ctx context.Context, arg RevokeIssuedCertificateSerialNumberParams) error {
	_, err := q.db.ExecContext(ctx, revokeIssuedCertificateSerialNumber, arg.SerialNumber, arg.RevokeDate, arg.RevokedBy)
	return err
}
